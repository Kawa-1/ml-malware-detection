<h1>K-NearestNeighbors</h1>

**Very simply** and **easy algorithm** for classification of data which is **distribution free** and **instance based**; that's why it is completely easy to use as it was mentioned before.
Computational complexity for testing is O(n) so it depends on the number of examples and for training is O(1).

'k' in KNN is a hyperparameter that refers to the **number of nearest neighbours to include in the majority of the voting process.**

kNN model was made with: metric of standard **Euclidean**, **auto algorithm** which attempts to decide the most appropriate algorithm (brute, kd_tree, ball_tree) based on the values passed to fit method, and **size of leaf** equals to 30.
	modificiation of those hyperparameters didn't affect significantly on accuracy of our model with this dataset.

Metrics of function classification_report are based on:

1. TN / True Negative: when a case was negative and predicted negative
2. TP / True Positive: when a case was positive and predicted positive
3. FN / False Negative: when a case was positive but predicted negative
4. FP / False Positive: when a case was negative but predicted positive

**Precision** – Tells us about accuracy of positive predictions
- Precision = TP/(TP + FP)

**Recall** – Tells us - What is the percentage of the positive case that have been caught
- Recall = TP/(TP + FN)

**F1 score** – Tells us what is the percentage of positive predictions that were correct
- F1 Score = 2*(Recall * Precision) / (Recall + Precision)


Preprocessed bytes files were converted into files based on Base-10 Number system due to easier conversion to image.
Chosen was PNG file format due to the fact of completely lossless compression which may result in producing more accurate results.
Here is the first problem of the conversion data which led us to lose some important features of malware (from BYTES files into another format of file, this image into different resolution and etc).
Also it is worth to mention that we are using GRAYSCALE images which has only one channel.

Next problem which we have encountered in processing bytes file into images is that, those files are varying in size, for instance:
BYTES file BrePaE2xAs9fJtqvN1Wp is a size of 54578kb and 6wHyQ3DVLMBtsxnhGvmo is a size of 189kb, so it is the reason why resizing those files into images of the same size to perfom
evaluation of ML models (of course for example Fully Connected Layers do the trick here) with good overall accuracy may be hard to do.

**NEAREST** was chosen method of resampling data of integers to images as it seemed to be one of the most reasonable resampling methods to do here. For further investigation we can also try: bilinear and bicubic.
Another problem is that some files turned out to be upsampled and other downsampled, so it is also the field for the investigation.

The research of this model was conducted on the same type of data what other models, however images were scaled to different sizes.
Here is the example how does the same image look like in different resolutions. Resizing was based on cv2.INTER_AREA which seems to be great interpolation method for shrinking images
(2hziOB94QdKyeqAXo8pM):

1. 256x256 </br>
![alt text](https://github.com/marcinele/ml-malware-detection/blob/main/knn/readme_images/2hziOB94QdKyeqAXo8pM_256x256.png)
2. 128x128 </br>
![alt text](https://github.com/marcinele/ml-malware-detection/blob/main/knn/readme_images/2hziOB94QdKyeqAXo8pM_128x128.png)
3. 32x32 </br>
![alt text](https://github.com/marcinele/ml-malware-detection/blob/main/knn/readme_images/2hziOB94QdKyeqAXo8pM_32x32.png)
4. 16x16 </br>
![alt text](https://github.com/marcinele/ml-malware-detection/blob/main/knn/readme_images/2hziOB94QdKyeqAXo8pM_16x16.png)
5. 8x8 </br>
![alt text](https://github.com/marcinele/ml-malware-detection/blob/main/knn/readme_images/2hziOB94QdKyeqAXo8pM_8x8.png)

In the theory, we should have been eliminating overfitting by downsampling images which result in less number of features as well as less complexity for kNN.

75% of data was sacrificed for training and 25% for testing purposes.

Resolution and hyperparameter K was chosen in brute-force experiments with little help of scientific articles.
The research conducted us to the result where image of the size 8x8 with K=4 turned out to be most accurated model.
Basing on one of the articles which stated that K can be chosen with the value of sqrt(n) led us to check it. Assuming that our features are all possible combinations of pixels in the image, 
with Quadratic function and statement written before about choosing appropiate K it can be calculated that our image of 8x8 pixels might have good accuracy with K=5.65. It was good point to start as we were evaluating
our model with varying K from 1 to 30:

8x8 pixels </br>
![alt text](https://github.com/marcinele/ml-malware-detection/blob/main/knn/readme_images/8x8_accuracy_neighbors.png)

It turned out that K=4 is the best fit here.
Performed cross-validation on 8x8 image with K=4 returned mean result of **75.31%** as we considered the metric - accuracy.

Below there are other researches for different resolutions:

4x4 pixels </br>
![alt text](https://github.com/marcinele/ml-malware-detection/blob/main/knn/readme_images/4x4_accuracy_neighbors.png)

32x32 pixels </br>
![alt text](https://github.com/marcinele/ml-malware-detection/blob/main/knn/readme_images/32x32_accuracy_neighbors.png)

128x128 pixels </br>
![alt text](https://github.com/marcinele/ml-malware-detection/blob/main/knn/readme_images/128x128_accuracy_neighbors.png)


Looking at the 128x128 pixels image in comparison with 8x8 pixel image, we can draw conclusions that the former mentioned image has too many features for our model.

Below is presented classification report for 8x8 image K=4
![alt text](https://github.com/marcinele/ml-malware-detection/blob/main/knn/readme_images/8x8_classification_report_K%3D4.PNG)
